### 5.3 原始值包装类型(primitive wrapper types)

为了方便操作原始值，ECMAScript 提供了3 种特殊的引用类型：**Boolean、Number 和String**。这些类型具有其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为.

每当用到某个原始值的方法或属性时，后台都会创建一个相应**原始包装类型的对象**，从而暴露出操作原始值的各种方法

案例:

let s1 = 'some text';

let s2 = s1.substring(2);

```js
//执行流程:
1.当访问s1时,是以阅读模式访问的,就是从内存中读取变量保存的值.
2.在阅读模式访问字符串值的时候,后台都会执行以下3步:
 2.1 创建一个String类型的实例;
 2.2 调用实例上特定的方法;
 2.3 销毁实例;

//伪代码
let s1 = new String('some text');
let s2 = s1.substring(2);
s1 = null;
```

这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3 步也会在后台发生，只不过使用的是Boolean 和Number 包装类型而已。

**引用类型与原始值包装类型的主要区别在于对象的生命周期**

引用类型: 通过new 实例化引用类型后，得到的实例会在离开作用域时被销毁;

原始类型: 自动创建的**原始值包装对象**则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法

```js
//不能在运行时,给原始值添加属性和方法
let s1 = 'some text';
s1.color = 'read';
console.log(s1.color); //undefined
//第二行代码运行时会临时创建一个String 对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的String 对象，但这个对象没有color 属性
```



**创建原始值包装对象的实例**

1.显式地使用Boolean、Number 和String 构造函数创建. 

2.Object构造函数的工厂方法

```js
//Object构造函数,可根据传入值的类型返回相应原始值包装类型的实例.

let obj = new Object('some text');
console.log(obj instanceof String); //true

如果传给Object 的是字符串，则会创建一个String 的实例。
如果是数值，则会创建Number 的实例。布尔值则会得到Boolean 的实例
```



**类型判断**

在原始值包装类型的实例上调用typeof 会返回"object"

**布尔值判断**

所有原始值包装对象都会转换为布尔值true。



使用new 调用原始值包装类型的构造函数，与调用同名的**转型函数**并不一样

```js
let value = '25';
let number = Number(value); //转型函数
console.log(typeof number); //'number'
let obj = new Number(value); //构造函数
console.log(typeof obj); //'object'
```



### 5.3.1 Boolean

创建一个Boolean 对象，就使用Boolean 构造函数并传入true 或false.

```js
let boo = new Boolean();
console.log(boo); //false
let boo = new Boolean(true); //Boolean {false}
```

Boolean 的实例会重写valueOf()方法，返回一个原始值true 或false。toString()方法被调用时也会被覆盖，返回字符串"true"或"false"



**原始值和引用值(Boolean对象)区别**

typeof操作符对原始值返回'boolean',引用值返回'object';

Boolean 对象是Boolean 类型的实例，在使用instaceof 操作符时返回true，但对原始值则返回false

```js
let falseObject = new Boolean(false);
let falseValue = false;

console.log(typeof falseObject); //object
console.log(typeof falseValue); //boolean
console.log(falseObject instanceof Boolean); //true
console.log(falseValue instanceof Boolean); //false
```



**使用建议**

理解原始布尔值和Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者



### 5.3.2 Number

Number 是对应数值的引用类型。要创建一个Number 对象，就使用Number 构造函数并传入一个数值

```js
let num = new Number();
console.log(num); // Number {0}
```

与Boolean 类型一样，Number 类型重写了valueOf()、toLocaleString()和toString()方法

valueOf()方法返回Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串

```js
let num = new Number();
console.log(num.valueOf()); //0 数字0

let num1 = 10;
console.log(num1.toString()); //'10'
console.log(num1.toString(2)); //'1010'
console.log(num1.toString(8)); //'12'
console.log(num1.toString(10)); //'10'
console.log(num1.toString(16)); //'a'
```



**数值格式化**

除了继承的方法，Number 类型还提供了几个用于将数值格式化为字符串的方法

toFixed()方法返回包含指定小数点位数的数值字符串

```js
let num = 10;
console.log(num.toFixed(2)); //'10.00'
```

如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位:

```js
let num = 10.005;
console.log(num.toFixed(2)); //'10.01'
```

toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 = 0.30000000000000004



toExponential()返回以科学记数法（也称为指数记数法）表示的数值字符串.toExponential()也接收一个参数，表示结果中小数的位数

```js
let num = 10;
console.log(num.toExponential(1)); //'1.0e+1'
```



如果想得到数值最适当的形式，那么可以使用toPrecision().

toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）

```js
let num = 99;
console.log(num.toPrecision(1)); //'1e+2'
console.log(num.toPrecision(2)); //'99'
console.log(num.toPrecision(3)); //'99.0'
```

在这个例子中，首先要用1 位数字表示数值99，得到"1e+2"，也就是100。因为99 不能只用1 位数字来精确表示，所以这个方法就将它舍入为100，这样就可以只用1 位数字（及其科学记数法形式）来表示了。用2 位数字表示99 得到"99"，用3 位数字则是"99.0"。本质上，toPrecision()方法会根据数值和精度来决定调用toFixed()还是toExponential()。为了以正确的小数位精确表示数值，这3 个方法都会向上或向下舍入。

**注意**

因此并不建议直接实例化Number 对象.  有潜在问题?

**类型判断**

```js
let numberObject = new Number(10);
let numberValue = 10;

console.log(typeof numberObject); //'object'
console.log(typeof numberValue); //'number'
console.log(numberObject instanceof Number); // true
console.log(numberValue instanceof Number); //false

//原始数值在调用typeof 时始终返回"number"，而Number 对象则返回"object"。类似地，Number对象是Number 类型的实例，而原始数值不是
```



**其他**

ES6 新增了Number.isInteger()方法，用于辨别一个数值是否保存为**整数**。有时候，小数位的0可能会让人误以为数值是一个浮点值

```js
console.log(Number.isInteger(1)); //true
console.log(Number.isInteger(1.00)); //true
console.log(Number.isInteger(1.01)); //false
```



IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从Number.MIN_SAFE_INTEGER（-2\*\*53 + 1）到Number.MAX_SAFE_INTEGER（2\*\*53 - 1）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用Number.isSafeInteger()方法：

```js
console.log(Number.isSafeInteger(-1*(2**53))); //false
console.log(Number.isSafeInteget(-1*(2**53)+1)); //true

console.log(Number.isSafeInteger(2**53)); //false
console.log(Number.isSafeInteger(2**53-1)); //true
```





### 5.3.3 String

String类型是字符串的对象表示,通过String构造函数创建.

```js
let stringObject = new String('hello world');
```



#### 1.方法/属性

String 对象的方法可以在所有字符串原始值上调用

3 个继承的方法valueOf()、toLocaleString()和toString()都返回对象的原始字符串值

length属性,表示字符串中字符的数量.注意，即使字符串中包含双字节字符（而不是单字节的ASCII 字符），也仍然会按单字符来计数



#### 2. JavaScript字符

JS字符串由16位code unit(代码单元)组成. 对多数字符来说，每16 位码元对应一个字符。换句话说，字符串的length 属性表示字符串包含多少16 位码元.

**charAt()方法**返回给定索引位置的字符，由传给方法的整数参数指定

```js
let msg = 'abcde';
console.log(msg.charAt(2)); //'c'
```

**charCodeAt()**方法可以查看指定码元的字符编码. 这个方法返回指定索引位置的码元值，索引以整数指定.

```js
let message = "abcde";
// Unicode "Latin small letter C"的编码是U+0063
console.log(message.charCodeAt(2)); // 99
```

fromCharCode()方法用于根据给定的UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：



